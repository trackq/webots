<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Streaming viewer</title>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css" />
  <link type="text/css" rel="stylesheet" href="/R2019b/wwi.css" />
  <style>
    html {
      font-family: "Arial", "Helvetica", "Verdana", "sans-serif";
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow-y: hidden;
    }

    .container {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      background: #272822;
    }

    .parent {
      display: flex;
      font-family: arial, sans-serif;
    }

    .item {
      width: 50%;
      color: #333;
      background: #fff;
      min-height: 500px;
    }

    .right {
      color: #333;
      background: #fff;
      padding: 2em;
    }

    .right ol {
      list-style-type: none;
    }

    #editor {
      margin: 2em 0 0 0;
      padding: 0;
      flex: 1;
      height: 100%;
      min-height: 600px;
    }
  </style>
  <script src="https://code.jquery.com/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
    integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
  <script src="https://www.cyberbotics.com/jquery-dialogextend/2.0.4/jquery.dialogextend.min.js"></script>
  <script src="https://cdn.jsdelivr.net/ace/1.2.6/min/ace.js"></script>
  <!-- <script src="https://pagecdn.io/lib/ace/1.4.6/ace.js" integrity="sha256-CVkji/u32aj2TeC+D13f7scFSIfphw2pmu4LaKWMSY8=" crossorigin="anonymous"></script> -->
  <script src="/R2019b/webots.min.js"></script>
  <script>
    $(function () {
      console.log("Ready load")

      var playerDiv = document.getElementById("playerDiv");
      view = new webots.View(playerDiv, false);
      //view.open("ws://localhost:1999/samples/robotbenchmark/pick_and_place/worlds/pick_and_place.wbt");
      view.open("ws://localhost:1999/robots/universal_robots/worlds/ure.wbt");

      var editor = ace.edit("editor");
      editor.setShowPrintMargin(false);
      editor.setHighlightActiveLine(false);

      editor.setTheme("ace/theme/monokai");
      editor.session.setMode("ace/mode/javascript");
    })
  </script>
</head>

<body>
  <div class="container">
    <div class="parent">

      <div class="item" id="playerDiv"></div>
      <!-- <div class="item"
        style="background: url(https://unsplash.it/800/300) center center no-repeat; background-size: cover;"></div> -->

      <div class="item right">
        <h2>Speed competition</h2>
        <ol>
          <li>âœ… Drive towards assembly line</li>
          <li>ðŸ‘‰Pick up cube</li>
          <li>ðŸ‘‰ Drive back to box</li>
          <li>ðŸ‘‰ Place cube in box</li>
        </ol>
        <h3>How to improve the performance?</h3>
        <p>The basic controller is an open-loop program that simply sets the velocity or position of the motors and
          waits for a given time until the robot reaches the desired position. There are different strategies to reduce
          the execution time. For example you can increase the motors velocity, tune the duration of the steps, and
          parallelize the motions.</p>
        <p>Instead of waiting for a predefined amount of time between the different motions, a more elegant and
          efficient solution is to use the PositionSensor values to exactly determine when the movement is completed.
        </p>
      </div>
    </div>

    <pre id="editor">

      #include <webots/distance_sensor.h>
      #include <webots/motor.h>
      #include <webots/position_sensor.h>
      #include <webots/robot.h>

      #include <stdio.h>

      #define TIME_STEP 32

      enum State { WAITING, GRASPING, ROTATING, RELEASING, ROTATING_BACK };

      int main(int argc, char **argv) {
        wb_robot_init();
        int counter = 0, i = 0;
        int state = WAITING;
        const double target_positions[] = {-1.88, -2.14, -2.38, -1.51};
        double speed = 1.0;

        if (argc == 2)
          sscanf(argv[1], "%lf", &speed);

        WbDeviceTag hand_motors[3];
        hand_motors[0] = wb_robot_get_device("finger_1_joint_1");
        hand_motors[1] = wb_robot_get_device("finger_2_joint_1");
        hand_motors[2] = wb_robot_get_device("finger_middle_joint_1");
        WbDeviceTag ur_motors[4];
        ur_motors[0] = wb_robot_get_device("shoulder_lift_joint");
        ur_motors[1] = wb_robot_get_device("elbow_joint");
        ur_motors[2] = wb_robot_get_device("wrist_1_joint");
        ur_motors[3] = wb_robot_get_device("wrist_2_joint");
        for (i = 0; i < 4; ++i)
          wb_motor_set_velocity(ur_motors[i], speed);

        WbDeviceTag distance_sensor = wb_robot_get_device("distance sensor");
        wb_distance_sensor_enable(distance_sensor, TIME_STEP);

        WbDeviceTag position_sensor = wb_robot_get_device("wrist_1_joint_sensor");
        wb_position_sensor_enable(position_sensor, TIME_STEP);

        while (wb_robot_step(TIME_STEP) != -1) {
          if (counter <= 0) {
            switch (state) {
              case WAITING:
                if (wb_distance_sensor_get_value(distance_sensor) < 500) {
                  state = GRASPING;
                  counter = 8;
                  printf("Grasping can\n");
                  for (i = 0; i < 3; ++i)
                    wb_motor_set_position(hand_motors[i], 0.85);
                }
                break;
              case GRASPING:
                for (i = 0; i < 4; ++i)
                  wb_motor_set_position(ur_motors[i], target_positions[i]);
                printf("Rotating arm\n");
                state = ROTATING;
                break;
              case ROTATING:
                if (wb_position_sensor_get_value(position_sensor) < -2.3) {
                  counter = 8;
                  printf("Releasing can\n");
                  state = RELEASING;
                  for (i = 0; i < 3; ++i)
                    wb_motor_set_position(hand_motors[i], 0);
                }
                break;
              case RELEASING:
                for (i = 0; i < 4; ++i)
                  wb_motor_set_position(ur_motors[i], 0.0);
                printf("Rotating arm back\n");
                state = ROTATING_BACK;
                break;
              case ROTATING_BACK:
                if (wb_position_sensor_get_value(position_sensor) > -0.1) {
                  state = WAITING;
                  printf("Waiting can\n");
                }
                break;
            }
          }
          counter--;
        };

        wb_robot_cleanup();
        return 0;
      }
    </pre>
</body>

</html>
